---
title: lowdb使用
size: 10451
---
兼容commonjs

db.js
```js
class DatabaseManager {
  constructor(filePath = './db.json') {
    this.filePath = filePath;
    this.db = null;
    this.init();
  }

  // Initialize database
  async init() {
    try {
      const { Low } = await import('lowdb');
      const { JSONFile } = await import('lowdb/node');
      this.adapter = new JSONFile(this.filePath);
      this.db = new Low(this.adapter, { data: [] });
      await this.db.read();
      
      // Set default data if db is empty
      if (!this.db.data) {
        this.db.data = { data: [] };
        await this.db.write();
      }
    } catch (error) {
      console.error('Failed to initialize database:', error);
    }
  }

  // CREATE - Add new record
  async create(item) {
    try {
      await this.db.read();
      
      // Generate ID if not provided
      if (!item.id) {
        const maxId = this.db.data.data.length > 0 
          ? Math.max(...this.db.data.data.map(i => i.id || 0))
          : 0;
        item.id = maxId + 1;
      }

      // Add timestamps
      item.createdAt = new Date().toISOString();
      item.updatedAt = new Date().toISOString();

      this.db.data.data.push(item);
      await this.db.write();
      
      return { success: true, data: item };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // READ - Get all records
  async findAll() {
    try {
      await this.db.read();
      return { success: true, data: this.db.data.data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // READ - Get record by ID
  async findById(id) {
    try {
      await this.db.read();
      const item = this.db.data.data.find(i => i.id === parseInt(id));
      
      if (!item) {
        return { success: false, error: 'Item not found' };
      }
      
      return { success: true, data: item };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // READ - Find records by criteria
  async findBy(criteria) {
    try {
      await this.db.read();
      const items = this.db.data.data.filter(item => {
        return Object.keys(criteria).every(key => 
          item[key] && item[key].toString().toLowerCase().includes(criteria[key].toString().toLowerCase())
        );
      });
      
      return { success: true, data: items };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // UPDATE - Update record by ID
  async update(id, updates) {
    try {
      await this.db.read();
      const index = this.db.data.data.findIndex(i => i.id === parseInt(id));
      
      if (index === -1) {
        return { success: false, error: 'Item not found' };
      }

      // Merge updates with existing data
      this.db.data.data[index] = {
        ...this.db.data.data[index],
        ...updates,
        id: parseInt(id), // Preserve original ID
        updatedAt: new Date().toISOString()
      };

      await this.db.write();
      
      return { success: true, data: this.db.data.data[index] };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // DELETE - Delete record by ID
  async delete(id) {
    try {
      await this.db.read();
      const index = this.db.data.data.findIndex(i => i.id === parseInt(id));
      
      if (index === -1) {
        return { success: false, error: 'Item not found' };
      }

      const deletedItem = this.db.data.data.splice(index, 1)[0];
      await this.db.write();
      
      return { success: true, data: deletedItem };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // DELETE - Delete all records
  async deleteAll() {
    try {
      await this.db.read();
      const deletedCount = this.db.data.data.length;
      this.db.data.data = [];
      await this.db.write();
      
      return { success: true, message: `Deleted ${deletedCount} items` };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // UTILITY - Count records
  async count() {
    try {
      await this.db.read();
      return { success: true, count: this.db.data.data.length };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

module.exports = DatabaseManager;
```

routers.js
```js
import express from 'express';
import DatabaseManager from './db.js';

const router = express.Router();
const db = new DatabaseManager('./api-data.json');

// Middleware for JSON parsing
router.use(express.json());

// GET /api/items - Get all items
router.get('/items', async (req, res) => {
  try {
    const { search, ...filters } = req.query;
    let result;

    if (search || Object.keys(filters).length > 0) {
      // Search with filters
      const criteria = search ? { name: search } : filters;
      result = await db.findBy(criteria);
    } else {
      // Get all items
      result = await db.findAll();
    }

    if (result.success) {
      res.json({
        success: true,
        data: result.data,
        count: result.data.length
      });
    } else {
      res.status(500).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/items/:id - Get item by ID
router.get('/items/:id', async (req, res) => {
  try {
    const result = await db.findById(req.params.id);
    
    if (result.success) {
      res.json({ success: true, data: result.data });
    } else {
      res.status(404).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/items - Create new item
router.post('/items', async (req, res) => {
  try {
    const result = await db.create(req.body);
    
    if (result.success) {
      res.status(201).json({ success: true, data: result.data });
    } else {
      res.status(400).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/items/:id - Update item
router.put('/items/:id', async (req, res) => {
  try {
    const result = await db.update(req.params.id, req.body);
    
    if (result.success) {
      res.json({ success: true, data: result.data });
    } else {
      res.status(404).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH /api/items/:id - Partial update
router.patch('/items/:id', async (req, res) => {
  try {
    const result = await db.update(req.params.id, req.body);
    
    if (result.success) {
      res.json({ success: true, data: result.data });
    } else {
      res.status(404).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/items/:id - Delete item
router.delete('/items/:id', async (req, res) => {
  try {
    const result = await db.delete(req.params.id);
    
    if (result.success) {
      res.json({ success: true, data: result.data });
    } else {
      res.status(404).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/items - Delete all items
router.delete('/items', async (req, res) => {
  try {
    const result = await db.deleteAll();
    
    if (result.success) {
      res.json({ success: true, message: result.message });
    } else {
      res.status(500).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/items/stats/count - Get item count
router.get('/items/stats/count', async (req, res) => {
  try {
    const result = await db.count();
    
    if (result.success) {
      res.json({ success: true, count: result.count });
    } else {
      res.status(500).json({ success: false, error: result.error });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

export default router;
```

server.js
```js
import express from 'express';
import cors from 'cors';
import apiRoutes from './routes.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api', apiRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ success: false, error: 'Route not found' });
});

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ success: false, error: 'Internal server error' });
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  console.log('API endpoints:');
  console.log('  GET    /api/items           - Get all items');
  console.log('  GET    /api/items/:id       - Get item by ID');
  console.log('  POST   /api/items           - Create new item');
  console.log('  PUT    /api/items/:id       - Update item');
  console.log('  PATCH  /api/items/:id       - Partial update');
  console.log('  DELETE /api/items/:id       - Delete item');
  console.log('  DELETE /api/items           - Delete all items');
  console.log('  GET    /api/items/stats/count - Get item count');
});
```


lowdb并发写入，加锁防止漏写
```js
const lockfile = require("proper-lockfile")

// CREATE - Add new record
async create(item) {
    const file = this.filePath
    let release
    try {
        // 加锁（带重试）
        release = await lockfile.lock(file, {
            retries: {
                retries: 5,
                factor: 1.2,
                minTimeout: 100,
                maxTimeout: 2000,
            },
        })

        await this.db.read()

        item.createdAt = new Date().toISOString()
        item.updatedAt = new Date().toISOString()

        this.db.data.data.push(item)
        await this.db.write()

        return { success: true }
    } catch (error) {
        return { success: false, error: error.message }
    } finally {
	    // 释放锁
        if (release) await release()
    }
}
```
