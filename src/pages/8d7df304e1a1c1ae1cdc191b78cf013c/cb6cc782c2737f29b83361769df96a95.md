---
title: escpos（小票打印）
size: 16687
---
API方式
```js
device.open(function(error){
  printer
  .font('a')
  .align('ct')
  .style('bu')
  .size(1, 1)
  .text('The quick brown fox jumps over the lazy dog')
  .text('敏捷的棕色狐狸跳过懒狗')
  .barcode('1234567', 'EAN8')
  .table(["One", "Two", "Three"])
  .tableCustom(
    [
      { text:"Left", align:"LEFT", width:0.33, style: 'B' },
      { text:"Center", align:"CENTER", width:0.33},
      { text:"Right", align:"RIGHT", width:0.33 }
    ],
    { encoding: 'cp857', size: [1, 1] } // Optional
  )
  .qrimage('https://github.com/song940/node-escpos', function(err){
    this.cut();
    this.close();
  });
});
```

使用canvas渲染，通过图片方式打印
```js

try {
	// 使用Canvas生成小票图片
	const generateReceiptCanvas = (data, title) => {
	    const width = 550
	    let height = 100 // 初始高度
	
	    // 计算需要的高度
	    const lineHeight = 30
	    const titleHeight = 80
	    const paddingTop = 40
	    const paddingBottom = 40
	    const dividerHeight = 20
	
	    // 计算商品行数
	    let itemLines = 0
	    data.forEach((item) => {
	        itemLines += 1 // 商品名称行
	        Object.keys(item.options || {}).forEach((key) => {
	            itemLines += item.options[key].length // 商品选项行数
	        })
	        itemLines += 1 // 分割线
	    })
	
	    height =
	        paddingTop +
	        titleHeight +
	        dividerHeight +
	        itemLines * lineHeight +
	        paddingBottom
	
	    // 创建Canvas
	    const canvas = createCanvas(width, height)
	    const ctx = canvas.getContext("2d")
	
	    // 设置白色背景
	    ctx.fillStyle = "#ffffff"
	    ctx.fillRect(0, 0, width, height)
	
	    // 设置文字颜色
	    ctx.fillStyle = "#000000"
	
	    let currentY = paddingTop
	
	    // 绘制订单号（居中，大字体）
	    ctx.font = "bold 32px"
	    ctx.textAlign = "center"
	    ctx.fillText(title, width / 2, currentY)
	    currentY += 50
	
	    // 绘制分割线
	    ctx.strokeStyle = "#000000"
	    ctx.lineWidth = 2
	    ctx.beginPath()
	    ctx.moveTo(20, currentY)
	    ctx.lineTo(width - 20, currentY)
	    ctx.stroke()
	    currentY += 30
	
	    // 绘制商品信息
	    ctx.font = "16px"
	    ctx.textAlign = "left"
	
	    data.forEach((item, index) => {
	        // 商品名称和数量
	        ctx.fillStyle = "#000000"
	        ctx.fillText(item.name, 20, currentY)
	        ctx.textAlign = "right"
	        ctx.fillText(`${item.qty}`, width - 20, currentY)
	        ctx.textAlign = "left"
	        currentY += lineHeight
	
	        // 商品选项
	        item.options.forEach((optionItem) => {
	            const { label, value, qty } = optionItem
	            ctx.fillStyle = "#666666"
	            ctx.font = "14px"
	            ctx.fillText(`    ${label}:`, 20, currentY)
	            ctx.textAlign = "right"
	            ctx.fillText(
	                `${value} × ${qty}`,
	                width - 20,
	                currentY
	            )
	            ctx.textAlign = "left"
	            currentY += lineHeight
	        })
	
	        // 商品分割线
	        if (index < data.length - 1) {
	            ctx.strokeStyle = "#cccccc"
	            ctx.lineWidth = 1
	            ctx.beginPath()
	            ctx.moveTo(20, currentY)
	            ctx.lineTo(width - 20, currentY)
	            ctx.stroke()
	            currentY += 20
	        }
	
	        ctx.font = "16px"
	        ctx.fillStyle = "#000000"
	    })
	
	    return canvas
	}
	// 使用ESC/POS打印Canvas生成的图片
	const printCanvasImage = async (canvas) => {
	    console.log("准备打印Canvas图片...")
	
	    try {
	        // 转换为Buffer
	        const imageBuffer = canvas.toBuffer("image/png")
	        const base64Image = new Buffer.from(imageBuffer).toString("base64")
	        const dataURI = "data:image/png;base64," + base64Image
	
	        // 创建网络连接
	        const device = new escpos.Network("ip address", 9100)
	        const printer = new escpos.Printer(device)
	
	        escpos.Image.load(dataURI, async (image) => {
	            await new Promise((resolve, reject) => {
	                device.open((error) => {
	                    if (error) {
	                        reject(error)
	                        return
	                    }
	
	                    try {
	                        // 打印图片
	                        printer
	                            .raster(image)
	                            .cut()
	                            .close(() => {
	                                resolve()
	                            })
	                    } catch (imgError) {
	                        console.error("Canvas图片处理错误:", imgError)
	                    }
	                })
	
	                console.log("Canvas图片打印完成")
	            })
	        })
	    } catch (error) {
	        console.error("Canvas打印错误:", error)
	    }
	}
	
	// 1. 生成Canvas
	const canvas = generateReceiptCanvas(orderItems, orderSn)

	// 2. 打印Canvas图片
	await printCanvasImage(canvas)
} catch (error) {
	console.error("Canvas打印流程错误:", error)
}
```

使用html渲染，通过图片方式打印
```js
try {
	// 生成HTML模板
	const generateHTMLTemplate = (data, title) => {
	    const contentHtml = data
	        .map(({ name, qty }) => {
	            return `
	            <div class="item">
	                <div class="item-row">
	                    <span class="item-name">${name}</span>
	                    <span class="item-qty">× ${qty}</span>
	                </div>
	            </div>
	        `
	        })
	        .join("")
	
	    return `
	        <!DOCTYPE html>
	        <html>
	        <head>
	            <meta charset="UTF-8">
	            <style>
	                html {
	                    font-size: 32px;
	                }
	                * {
	                    margin: 0;
	                    padding: 0;
	                    box-sizing: border-box;
	                }
	                
	                body {
	                    width: 550px;
	                    font-family: 'Microsoft YaHei', Arial, sans-serif;
	                    background: white;
	                    color: #000;
	                }
	                
	                .receipt {
	                    width: 100%;
	                }
	                
	                .order-number {
	                    text-align: center;
	                    font-size: 2rem;
	                    font-weight: bold;
	                    margin-bottom: 20px;
	                    padding: 10px 0;
	                }
	                
	                .divider {
	                    width: 100%;
	                    height: 2px;
	                    background: #000;
	                    margin: 15px 0;
	                }
	                
	                .item {
	                    margin-bottom: 20px;
	                }
	                
	                .item-row {
	                    display: flex;
	                    justify-content: space-between;
	                    align-items: center;
	                    margin-bottom: 8px;
	                    font-size: 1rem;
	                    font-weight: 500;
	                }
	                
	                .item-name {
	                    flex: 1;
	                    text-align: left;
	                    padding-right: 10px;
	                }
	                
	                .item-qty {
	                    text-align: right;
	                    font-weight: bold;
	                }
	                
	                .thin-divider {
	                    width: 100%;
	                    height: 1px;
	                    background: #ddd;
	                    margin: 10px 0;
	                }
	                
	                .footer {
	                    height: 40px;
	                }
	            </style>
	        </head>
	        <body>
	            <div class="receipt">
	                <div class="order-number">${title}</div>
	                <div class="divider"></div>
	                ${contentHtml}
	                <div class="footer"></div>
	            </div>
	        </body>
	        </html>
	    `
	}
	const getChromiumPath = () => {
	    const platform = os.platform();
	    
	    if (platform === 'win32') {
	        // Windows paths
	        const windowsPaths = [
	            'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
	            'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
	            'C:\\Users\\' + os.userInfo().username + '\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe',
	        ];
	        
	        const fs = require('fs');
	        for (const path of windowsPaths) {
	            if (fs.existsSync(path)) {
	                return path;
	            }
	        }
	    } else if (platform === 'darwin') {
	        // macOS paths
	        const macPaths = [
	            '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
	            '/Applications/Chromium.app/Contents/MacOS/Chromium',
	        ];
	        
	        const fs = require('fs');
	        for (const path of macPaths) {
	            if (fs.existsSync(path)) {
	                return path;
	            }
	        }
	    } else {
	        // Linux paths
	        const linuxPaths = [
	            '/usr/bin/google-chrome',
	            '/usr/bin/google-chrome-stable',
	            '/usr/bin/chromium-browser',
	            '/usr/bin/chromium',
	        ];
	        
	        const fs = require('fs');
	        for (const path of linuxPaths) {
	            if (fs.existsSync(path)) {
	                return path;
	            }
	        }
	    }
	    
	    return null;
	}
	// 将HTML转换为图片
	const htmlToImage = async (html) => {
	    const browser = await puppeteer.launch({
	        headless: true,
	        timeout: 30000,
	        // Puppeteer（或 Playwright）下载的 Chromium 可执行文件是针对特定操作系统的
	        // executablePath: path.resolve(__dirname, 'path/to/your/windows/chromium.exe'), // 替换为你的Windows Chromium路径
	        executablePath: getChromiumPath(),
	        args: ["--no-sandbox", "--disable-setuid-sandbox"],
	    })
	
	    try {
	        const page = await browser.newPage()
	        await page.setContent(html)
	
	        // 等待页面完全加载
	        ;(await page.waitForLoadState?.("networkidle")) ||
	            new Promise((resolve) => setTimeout(resolve, 1000))
	
	        // 获取内容的实际高度
	        const contentHeight = await page.evaluate(() => {
	            return document.body.scrollHeight
	        })
	
	        // 设置视口大小
	        await page.setViewport({
	            width: 480,
	            height: contentHeight,
	        })
	
	        // 截图
	        const imageBuffer = await page.screenshot({
	            type: "png",
	            fullPage: true,
	            omitBackground: false,
	        })
	
	        return imageBuffer
	    } finally {
	        await browser.close()
	    }
	}
	// 使用ESC/POS打印图片
	const printImage = async (imageBuffer) => {
	    console.log("准备打印图片...")
	
	    try {
	        const base64Image = imageBuffer.toString("base64")
	        const dataURI = "data:image/png;base64," + base64Image
	        // 创建网络连接
	        const device = new escpos.Network("ip address", 9100)
	        const printer = new escpos.Printer(device)
	
	        escpos.Image.load(dataURI, async (image) => {
	            await new Promise((resolve, reject) => {
	                device.open((error) => {
	                    if (error) {
	                        reject(error)
	                        return
	                    }
	
	                    try {
	                        // 打印图片
	                        printer
	                            .raster(image)
	                            .cut()
	                            .close(() => {
	                                resolve()
	                            })
	                        
	                        console.log("图片打印完成")
	                    } catch (imgError) {
	                        console.error("Canvas图片处理错误:", imgError)
	                    }
	                })
	            })
	        })
	    } catch (error) {
	        console.error("打印错误:", error)
	    }
	}
	// 1. 生成HTML
	const html = generateHTMLTemplate(data, title)

	// 2. 转换为图片
	const imageBuffer = await htmlToImage(html)

	// 3. 打印图片
	await printImage(imageBuffer)
} catch (error) {
	console.error("打印流程错误:", error)
}
```

不依赖node，纯前端方式打印
```ts
import html2canvas from "html2canvas-pro"

const canvasToEscPosRaster = useCallback((canvas: HTMLCanvasElement) => {
    const ctx = canvas.getContext("2d")
    if (!ctx) throw new Error("无法获取 canvas context")

    const width = canvas.width
    const height = canvas.height
    const img = ctx.getImageData(0, 0, width, height)
    const pixels = img.data

    // Calculate byte width (8 pixels per byte)
    const widthBytes = Math.ceil(width / 8)
    const data = new Uint8Array(widthBytes * height)

    // Convert to monochrome bitmap
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4
            const r = pixels[i]
            const g = pixels[i + 1]
            const b = pixels[i + 2]
            const a = pixels[i + 3]

            const alpha = a / 255
            const brightness =
                (r * 0.299 + g * 0.587 + b * 0.114) * alpha + 255 * (1 - alpha)

            // Black pixel if brightness < 127
            if (brightness < 127) {
                const byteIndex = y * widthBytes + Math.floor(x / 8)
                const bitPosition = 7 - (x % 8)
                data[byteIndex] |= 1 << bitPosition
            }
        }
    }

    // Build complete ESC/POS command sequence
    const commands: number[] = []

    // 1. 初始化打印机
    commands.push(0x1b, 0x40)

    // 2. Reset to standard mode (cancel any text encoding mode)
    commands.push(0x1b, 0x74, 0x00) // ESC t 0 - Select standard character set

    // 3. Set line spacing to 0 for graphics (ESC 3 n)
    commands.push(0x1b, 0x33, 0x00)

    // 4. GS v 0 - Print raster bitmap
    // Format: GS v 0 m xL xH yL yH [data]
    const m = 0x00 // Normal mode (no scaling)
    const xL = widthBytes & 0xff
    const xH = (widthBytes >> 8) & 0xff
    const yL = height & 0xff
    const yH = (height >> 8) & 0xff

    commands.push(0x1d, 0x76, 0x30, m, xL, xH, yL, yH)

    // Create final buffer with space for image data and trailing commands
    const commandsArray = new Uint8Array(commands)
    const totalLength = commandsArray.length + data.length + 20
    const output = new Uint8Array(totalLength)

    // 写入位图数据
    output.set(commandsArray, 0)
    output.set(data, commandsArray.length)

    let idx = commandsArray.length + data.length

    // 5. 图像打印完后进纸 3 行
    output[idx++] = 0x1b
    output[idx++] = 0x64
    output[idx++] = 0x03

    // 6. Restore default line spacing (ESC 2)
    output[idx++] = 0x1b
    output[idx++] = 0x32

    // 7. 切纸
    output[idx++] = 0x1d
    output[idx++] = 0x56
    output[idx++] = 0x42
    output[idx++] = 0x00

    return output.slice(0, idx)
}, [])


try {
    const canvas = await html2canvas(element, {
        // 注意需要配合打印机的dpi、最大可打印宽度、element的宽度来设置
        scale: 2
    })

    const dataUrl = canvas.toDataURL("image/png")
    setPreviewDataUrl(dataUrl)

    // Convert to ESC/POS commands
    const bytes = canvasToEscPosRaster(canvas)

    // Send to printer
    await toPrint(bytes)
} catch (err) {
    console.error("Print failed:", err)
    throw err
}
```

canvas元素宽度计算
- 1 英寸等于 25.4 毫米，根据此公式可以计算出最大可打印像素数。
- `canvasToEscPosRaster` 函数会再将 **最大可打印像素数** 的位图转换为 ESC/POS 命令，并以 **72 字节** ($576 / 8 = 72$) 的宽度参数发送给打印机

**“最大可打印像素数”** 等于 **“最大打印宽度”**（以毫米计）除以 **25.4**（这是一个常数，表示每英寸所包含的毫米数），然后将所得的结果乘以 **“分辨率”**（以 DPI，即每英寸点数计）。

这个过程确保：使用Web布局，完美匹配了打印机的物理限制，避免内容被截断或者乱码的问题

ref:
- https://github.com/lsongdev/node-escpos/issues/358#issuecomment-884995107
- https://juejin.cn/post/6844903756857868301
